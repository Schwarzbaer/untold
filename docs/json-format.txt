Basic Workcycle
---------------

* Basic workcycle
  * Untold generates a dict of presentation, actables (list of Actions) and
    autoacts (an Action to take if the user doesn't act) for the frontend to
    present to the user.
  * The frontend passes the selected Action to Untold to enact.
  * This continues until the story ends due to a special exit node, at which
    point StoryExited is raised.

Document Format
---------------

* The most minimal story:
      {'start_node': 'start',
       'story': [{'id': 'start',
                  'special': 'exit'}]}
* ...with some more metadata:
      {'title': 'Example from the docs',
       'author': 'TheCheapestPixels',
       'start_node': 'start',
       'story': [{'id': 'start',
                  'special': 'exit'}]}
* Typical story node:
      {'scene': {'presentation': {'text': 'This is the scene as it presents itself.'},
                 'actable': [{'text': 'This is a possible action you can take.',
                              'result': {'set': {'var': 'foo',
                                                 'val': 17},
                                         'goto': 'target_node'}}],
                 'autoact': {'set': {'var': 'foo',
                                     'val': 23},
                             'goto': 'target_node'}}}
* ...because
  * STORY has a list of nodes with nodes with either 'scene' (SCENE) or 's√ºecial'
  * SCENE nodes contain an optional presentation (?), and 'actable' (ACTION) and/or 'autoact' (ACTION)
  * ACTION nodes contain 'set' and/or 'goto'


Scripting Elements
------------------

* case/cond:
      {'case': [{'cond': <condition>,
                 <other_fields>: ...},
                {'cond': <condition>,
                 <other_fields>: ...}]}
  During an evaluation of the node, the case will be (virtually) removed, and
  the other_fields from the first leaf node in the cases list for which cond is
  true will be added to the node.
* choice/weight:
      {choice: [{'weight': 3,
                 <other_fields>: ...},
                {'weight': 2,
                 <other_fields>: ...}]}
  Similar to case in functionality, except that the sub-node actually used is
  chosen at random. This choice is biased by the weights that sub-nodes have,
  with each sub-nodes chance of being chosen being its weight divided by the
  sum of weights.
  If no weight is given for a sub-node, then its weight implicitly is 1.

* if:
      {<list_using_field>: [{'if': <condition>,
                             <other_fields>: ...},
                            {'if': <condition>,
                             <other_fields>: ...}]}
  When a list is evaluated, only the nodes for which the if-condition is true
  (or which do not have an if-field) are considered.

Conditions
----------

Conditions are expressions that allow to write stories that are reactive to the current state of the story. They return a value. Usually, i.e. in a case/cond, it is relevant whether that value is equivalent to a boolean True or False.

* None, booleans, strings, ints and floats get returned verbatim.
* Constants in the story (will return that value):
      {'const': <foo>}
* References to variables (value will be None if variable isn't specified in the state, its value otherwise):
      {'var': 'foo'}
* Equality test between two sub-conditions
      {'op': '==',
       'varl': {<cond1>},
       'varr': {<cond2>}}
* Is foo absent in the state?
      {'op': '==',
       'varl': {'var': 'foo'},
       'varr': {'const': None}}
* (foo == True) == (bar == False)
      {'op': '==',
       'varl': {'op': '==',
                'varl': {'var': 'foo'},
                'varr': {'const': True}},
       'varr': {'op': '==',
                'varl': {'var': 'bar'},
                'varr': {'const': False}}}
* Other operators: !=, <, <=, >, >=
* TODO
  * String operators? ~=?
  * sum, abs, other expressions?
